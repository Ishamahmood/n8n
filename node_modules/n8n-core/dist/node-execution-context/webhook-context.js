"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookContext = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const NodeExecuteFunctions_1 = require("../NodeExecuteFunctions");
const node_execution_context_1 = require("./node-execution-context");
class WebhookContext extends node_execution_context_1.NodeExecutionContext {
    constructor(workflow, node, additionalData, mode, webhookData, closeFunctions, runExecutionData) {
        super(workflow, node, additionalData, mode);
        this.webhookData = webhookData;
        this.closeFunctions = closeFunctions;
        this.runExecutionData = runExecutionData;
        this.helpers = {
            createDeferredPromise: n8n_workflow_1.createDeferredPromise,
            returnJsonArray: NodeExecuteFunctions_1.returnJsonArray,
            ...(0, NodeExecuteFunctions_1.getRequestHelperFunctions)(workflow, node, additionalData),
            ...(0, NodeExecuteFunctions_1.getBinaryHelperFunctions)(additionalData, workflow.id),
        };
        this.nodeHelpers = {
            copyBinaryFile: async (filePath, fileName, mimeType) => await (0, NodeExecuteFunctions_1.copyBinaryFile)(this.workflow.id, this.additionalData.executionId, filePath, fileName, mimeType),
        };
    }
    async getCredentials(type) {
        return await (0, NodeExecuteFunctions_1.getCredentials)(this.workflow, this.node, type, this.additionalData, this.mode);
    }
    getBodyData() {
        return this.assertHttpRequest().body;
    }
    getHeaderData() {
        return this.assertHttpRequest().headers;
    }
    getParamsData() {
        return this.assertHttpRequest().params;
    }
    getQueryData() {
        return this.assertHttpRequest().query;
    }
    getRequestObject() {
        return this.assertHttpRequest();
    }
    getResponseObject() {
        if (this.additionalData.httpResponse === undefined) {
            throw new n8n_workflow_1.ApplicationError('Response is missing');
        }
        return this.additionalData.httpResponse;
    }
    assertHttpRequest() {
        const { httpRequest } = this.additionalData;
        if (httpRequest === undefined) {
            throw new n8n_workflow_1.ApplicationError('Request is missing');
        }
        return httpRequest;
    }
    getNodeWebhookUrl(name) {
        return (0, NodeExecuteFunctions_1.getNodeWebhookUrl)(name, this.workflow, this.node, this.additionalData, this.mode, (0, NodeExecuteFunctions_1.getAdditionalKeys)(this.additionalData, this.mode, null));
    }
    getWebhookName() {
        return this.webhookData.webhookDescription.name;
    }
    async getInputConnectionData(inputName, itemIndex) {
        const connectionInputData = [
            { json: this.additionalData.httpRequest?.body || {} },
        ];
        const runExecutionData = {
            resultData: {
                runData: {},
            },
        };
        const executeData = {
            data: {
                main: [connectionInputData],
            },
            node: this.node,
            source: null,
        };
        const runIndex = 0;
        return await NodeExecuteFunctions_1.getInputConnectionData.call(this, this.workflow, runExecutionData, runIndex, connectionInputData, {}, this.additionalData, executeData, this.mode, this.closeFunctions, inputName, itemIndex);
    }
    evaluateExpression(expression, evaluateItemIndex) {
        const itemIndex = evaluateItemIndex ?? 0;
        const runIndex = 0;
        let connectionInputData = [];
        let executionData;
        if (this.runExecutionData?.executionData !== undefined) {
            executionData = this.runExecutionData.executionData.nodeExecutionStack[0];
            if (executionData !== undefined) {
                connectionInputData = executionData.data.main[0];
            }
        }
        const additionalKeys = (0, NodeExecuteFunctions_1.getAdditionalKeys)(this.additionalData, this.mode, this.runExecutionData);
        return this.workflow.expression.resolveSimpleParameterValue(`=${expression}`, {}, this.runExecutionData, runIndex, itemIndex, this.node.name, connectionInputData, this.mode, additionalKeys, executionData);
    }
    getNodeParameter(parameterName, fallbackValue, options) {
        const itemIndex = 0;
        const runIndex = 0;
        let connectionInputData = [];
        let executionData;
        if (this.runExecutionData?.executionData !== undefined) {
            executionData = this.runExecutionData.executionData.nodeExecutionStack[0];
            if (executionData !== undefined) {
                connectionInputData = executionData.data.main[0];
            }
        }
        const additionalKeys = (0, NodeExecuteFunctions_1.getAdditionalKeys)(this.additionalData, this.mode, this.runExecutionData);
        return (0, NodeExecuteFunctions_1.getNodeParameter)(this.workflow, this.runExecutionData, runIndex, connectionInputData, this.node, parameterName, itemIndex, this.mode, additionalKeys, executionData, fallbackValue, options);
    }
}
exports.WebhookContext = WebhookContext;
//# sourceMappingURL=webhook-context.js.map