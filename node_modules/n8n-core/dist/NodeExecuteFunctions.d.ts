import type { AxiosRequestConfig } from 'axios';
import { IncomingMessage } from 'http';
import type { BinaryHelperFunctions, CloseFunction, FileSystemHelperFunctions, IAdditionalCredentialOptions, IAllExecuteFunctions, IBinaryData, ICredentialDataDecryptedObject, ICredentialTestFunctions, IDataObject, IExecuteData, IExecuteFunctions, IExecuteSingleFunctions, IGetNodeParameterOptions, IHookFunctions, IHttpRequestOptions, IN8nHttpFullResponse, IN8nHttpResponse, INode, INodeExecutionData, INodeType, IOAuth2Options, IPairedItemData, IPollFunctions, IRequestOptions, IRunExecutionData, ITaskDataConnections, ITriggerFunctions, IWebhookData, IWebhookDescription, IWebhookFunctions, IWorkflowDataProxyAdditionalKeys, IWorkflowExecuteAdditionalData, NodeExecutionWithMetadata, NodeHelperFunctions, NodeParameterValueType, PaginationOptions, RequestHelperFunctions, Workflow, WorkflowActivateMode, WorkflowExecuteMode, EnsureTypeOptions, SSHTunnelFunctions, DeduplicationHelperFunctions, IDeduplicationOutput, IDeduplicationOutputItems, ICheckProcessedOptions, DeduplicationScope, DeduplicationItemTypes, ICheckProcessedContextData, ISupplyDataFunctions, WebhookType, SchedulingFunctions } from 'n8n-workflow';
import { NodeConnectionType } from 'n8n-workflow';
import { Readable } from 'stream';
import type { BinaryData } from './BinaryData/types';
export declare const validateUrl: (url?: string) => boolean;
export declare function parseRequestObject(requestObject: IRequestOptions): Promise<AxiosRequestConfig<any>>;
export declare function parseIncomingMessage(message: IncomingMessage): void;
export declare function binaryToString(body: Buffer | Readable, encoding?: BufferEncoding): Promise<string>;
export declare function proxyRequestToAxios(workflow: Workflow | undefined, additionalData: IWorkflowExecuteAdditionalData | undefined, node: INode | undefined, uriOrObject: string | IRequestOptions, options?: IRequestOptions): Promise<any>;
export declare const removeEmptyBody: (requestOptions: IHttpRequestOptions | IRequestOptions) => void;
export declare function httpRequest(requestOptions: IHttpRequestOptions): Promise<IN8nHttpFullResponse | IN8nHttpResponse>;
export declare function getBinaryPath(binaryDataId: string): string;
export declare function getBinaryMetadata(binaryDataId: string): Promise<BinaryData.Metadata>;
export declare function getBinaryStream(binaryDataId: string, chunkSize?: number): Promise<Readable>;
export declare function assertBinaryData(inputData: ITaskDataConnections, node: INode, itemIndex: number, propertyName: string, inputIndex: number): IBinaryData;
export declare function getBinaryDataBuffer(inputData: ITaskDataConnections, itemIndex: number, propertyName: string, inputIndex: number): Promise<Buffer>;
export declare function setBinaryDataBuffer(binaryData: IBinaryData, bufferOrStream: Buffer | Readable, workflowId: string, executionId: string): Promise<IBinaryData>;
export declare function copyBinaryFile(workflowId: string, executionId: string, filePath: string, fileName: string, mimeType?: string): Promise<IBinaryData>;
export declare function prepareBinaryData(binaryData: Buffer | Readable, executionId: string, workflowId: string, filePath?: string, mimeType?: string): Promise<IBinaryData>;
export declare function checkProcessedAndRecord(items: DeduplicationItemTypes[], scope: DeduplicationScope, contextData: ICheckProcessedContextData, options: ICheckProcessedOptions): Promise<IDeduplicationOutput>;
export declare function checkProcessedItemsAndRecord(key: string, items: IDataObject[], scope: DeduplicationScope, contextData: ICheckProcessedContextData, options: ICheckProcessedOptions): Promise<IDeduplicationOutputItems>;
export declare function removeProcessed(items: DeduplicationItemTypes[], scope: DeduplicationScope, contextData: ICheckProcessedContextData, options: ICheckProcessedOptions): Promise<void>;
export declare function clearAllProcessedItems(scope: DeduplicationScope, contextData: ICheckProcessedContextData, options: ICheckProcessedOptions): Promise<void>;
export declare function getProcessedDataCount(scope: DeduplicationScope, contextData: ICheckProcessedContextData, options: ICheckProcessedOptions): Promise<number>;
export declare function applyPaginationRequestData(requestData: IRequestOptions, paginationRequestData: PaginationOptions['request']): IRequestOptions;
export declare function requestOAuth2(this: IAllExecuteFunctions, credentialsType: string, requestOptions: IHttpRequestOptions | IRequestOptions, node: INode, additionalData: IWorkflowExecuteAdditionalData, oAuth2Options?: IOAuth2Options, isN8nRequest?: boolean): Promise<any>;
export declare function requestOAuth1(this: IAllExecuteFunctions, credentialsType: string, requestOptions: IHttpRequestOptions | IRequestOptions, isN8nRequest?: boolean): Promise<any>;
export declare function httpRequestWithAuthentication(this: IAllExecuteFunctions, credentialsType: string, requestOptions: IHttpRequestOptions, workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, additionalCredentialOptions?: IAdditionalCredentialOptions): Promise<any>;
export declare function returnJsonArray(jsonData: IDataObject | IDataObject[]): INodeExecutionData[];
export declare function constructExecutionMetaData(inputData: INodeExecutionData[], options: {
    itemData: IPairedItemData | IPairedItemData[];
}): NodeExecutionWithMetadata[];
export declare function normalizeItems(executionData: INodeExecutionData | INodeExecutionData[]): INodeExecutionData[];
export declare function requestWithAuthentication(this: IAllExecuteFunctions, credentialsType: string, requestOptions: IRequestOptions, workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, additionalCredentialOptions?: IAdditionalCredentialOptions, itemIndex?: number): Promise<any>;
export declare function getAdditionalKeys(additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, runExecutionData: IRunExecutionData | null, options?: {
    secretsEnabled?: boolean;
}): IWorkflowDataProxyAdditionalKeys;
export declare function getCredentials<T extends object = ICredentialDataDecryptedObject>(workflow: Workflow, node: INode, type: string, additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, executeData?: IExecuteData, runExecutionData?: IRunExecutionData | null, runIndex?: number, connectionInputData?: INodeExecutionData[], itemIndex?: number): Promise<T>;
export declare function cleanupParameterData(inputData: NodeParameterValueType): void;
export declare const validateValueAgainstSchema: (node: INode, nodeType: INodeType, parameterValue: string | number | boolean | object | null | undefined, parameterName: string, runIndex: number, itemIndex: number) => any;
export declare function ensureType(toType: EnsureTypeOptions, parameterValue: any, parameterName: string, errorOptions?: {
    itemIndex?: number;
    runIndex?: number;
    nodeCause?: string;
}): string | number | boolean | object;
export declare function getNodeParameter(workflow: Workflow, runExecutionData: IRunExecutionData | null, runIndex: number, connectionInputData: INodeExecutionData[], node: INode, parameterName: string, itemIndex: number, mode: WorkflowExecuteMode, additionalKeys: IWorkflowDataProxyAdditionalKeys, executeData?: IExecuteData, fallbackValue?: any, options?: IGetNodeParameterOptions): NodeParameterValueType | object;
export declare function continueOnFail(node: INode): boolean;
export declare function getNodeWebhookUrl(name: WebhookType, workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, additionalKeys: IWorkflowDataProxyAdditionalKeys, isTest?: boolean): string | undefined;
export declare function getWebhookDescription(name: WebhookType, workflow: Workflow, node: INode): IWebhookDescription | undefined;
export declare function getInputConnectionData(this: IAllExecuteFunctions, workflow: Workflow, runExecutionData: IRunExecutionData, runIndex: number, connectionInputData: INodeExecutionData[], inputData: ITaskDataConnections, additionalData: IWorkflowExecuteAdditionalData, executeData: IExecuteData, mode: WorkflowExecuteMode, closeFunctions: CloseFunction[], inputName: NodeConnectionType, itemIndex: number, abortSignal?: AbortSignal): Promise<unknown>;
export declare const getRequestHelperFunctions: (workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, runExecutionData?: IRunExecutionData | null, connectionInputData?: INodeExecutionData[]) => RequestHelperFunctions;
export declare const getSSHTunnelFunctions: () => SSHTunnelFunctions;
export declare const getSchedulingFunctions: (workflow: Workflow) => SchedulingFunctions;
export declare function isFilePathBlocked(filePath: string): boolean;
export declare const getFileSystemHelperFunctions: (node: INode) => FileSystemHelperFunctions;
export declare const getNodeHelperFunctions: ({ executionId }: IWorkflowExecuteAdditionalData, workflowId: string) => NodeHelperFunctions;
export declare const getBinaryHelperFunctions: ({ executionId }: IWorkflowExecuteAdditionalData, workflowId: string) => BinaryHelperFunctions;
export declare const getCheckProcessedHelperFunctions: (workflow: Workflow, node: INode) => DeduplicationHelperFunctions;
export declare function copyInputItems(items: INodeExecutionData[], properties: string[]): IDataObject[];
export declare function getExecutePollFunctions(workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, activation: WorkflowActivateMode): IPollFunctions;
export declare function getExecuteTriggerFunctions(workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, activation: WorkflowActivateMode): ITriggerFunctions;
export declare function getExecuteFunctions(workflow: Workflow, runExecutionData: IRunExecutionData, runIndex: number, connectionInputData: INodeExecutionData[], inputData: ITaskDataConnections, node: INode, additionalData: IWorkflowExecuteAdditionalData, executeData: IExecuteData, mode: WorkflowExecuteMode, closeFunctions: CloseFunction[], abortSignal?: AbortSignal): IExecuteFunctions;
export declare function getSupplyDataFunctions(workflow: Workflow, runExecutionData: IRunExecutionData, runIndex: number, connectionInputData: INodeExecutionData[], inputData: ITaskDataConnections, node: INode, additionalData: IWorkflowExecuteAdditionalData, executeData: IExecuteData, mode: WorkflowExecuteMode, closeFunctions: CloseFunction[], abortSignal?: AbortSignal): ISupplyDataFunctions;
export declare function getExecuteSingleFunctions(workflow: Workflow, runExecutionData: IRunExecutionData, runIndex: number, connectionInputData: INodeExecutionData[], inputData: ITaskDataConnections, node: INode, itemIndex: number, additionalData: IWorkflowExecuteAdditionalData, executeData: IExecuteData, mode: WorkflowExecuteMode, abortSignal?: AbortSignal): IExecuteSingleFunctions;
export declare function getCredentialTestFunctions(): ICredentialTestFunctions;
export declare function getExecuteHookFunctions(workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, activation: WorkflowActivateMode, webhookData?: IWebhookData): IHookFunctions;
export declare function getExecuteWebhookFunctions(workflow: Workflow, node: INode, additionalData: IWorkflowExecuteAdditionalData, mode: WorkflowExecuteMode, webhookData: IWebhookData, closeFunctions: CloseFunction[], runExecutionData: IRunExecutionData | null): IWebhookFunctions;
