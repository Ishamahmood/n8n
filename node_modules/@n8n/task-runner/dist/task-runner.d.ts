import { WebSocket } from 'ws';
import type { BaseRunnerConfig } from './config/base-runner-config';
import type { BrokerMessage, RunnerMessage } from './message-types';
import { TaskRunnerNodeTypes } from './node-types';
import { type TaskResultData } from './runner-types';
export interface Task<T = unknown> {
    taskId: string;
    settings?: T;
    active: boolean;
    cancelled: boolean;
}
export interface TaskOffer {
    offerId: string;
    validUntil: bigint;
}
interface DataRequest {
    requestId: string;
    resolve: (data: unknown) => void;
    reject: (error: unknown) => void;
}
interface NodeTypesRequest {
    requestId: string;
    resolve: (data: unknown) => void;
    reject: (error: unknown) => void;
}
interface RPCCall {
    callId: string;
    resolve: (data: unknown) => void;
    reject: (error: unknown) => void;
}
export interface RPCCallObject {
    [name: string]: ((...args: unknown[]) => Promise<unknown>) | RPCCallObject;
}
export interface TaskRunnerOpts extends BaseRunnerConfig {
    taskType: string;
    name?: string;
}
export declare abstract class TaskRunner {
    id: string;
    ws: WebSocket;
    canSendOffers: boolean;
    runningTasks: Map<Task['taskId'], Task>;
    offerInterval: NodeJS.Timeout | undefined;
    openOffers: Map<TaskOffer['offerId'], TaskOffer>;
    dataRequests: Map<DataRequest['requestId'], DataRequest>;
    nodeTypesRequests: Map<NodeTypesRequest['requestId'], NodeTypesRequest>;
    rpcCalls: Map<RPCCall['callId'], RPCCall>;
    nodeTypes: TaskRunnerNodeTypes;
    taskType: string;
    maxConcurrency: number;
    name: string;
    constructor(opts: TaskRunnerOpts);
    private receiveMessage;
    private stopTaskOffers;
    private startTaskOffers;
    deleteStaleOffers(): void;
    sendOffers(): void;
    send(message: RunnerMessage.ToBroker.All): void;
    onMessage(message: BrokerMessage.ToRunner.All): void;
    processDataResponse(requestId: string, data: unknown): void;
    processNodeTypesResponse(requestId: string, nodeTypes: unknown): void;
    hasOpenTasks(): boolean;
    offerAccepted(offerId: string, taskId: string): void;
    taskCancelled(taskId: string): void;
    taskErrored(taskId: string, error: unknown): void;
    taskDone(taskId: string, data: RunnerMessage.ToBroker.TaskDone['data']): void;
    receivedSettings(taskId: string, settings: unknown): Promise<void>;
    executeTask(_task: Task): Promise<TaskResultData>;
    requestNodeTypes<T = unknown>(taskId: Task['taskId'], requestParams: RunnerMessage.ToBroker.NodeTypesRequest['requestParams']): Promise<T>;
    requestData<T = unknown>(taskId: Task['taskId'], requestParams: RunnerMessage.ToBroker.TaskDataRequest['requestParams']): Promise<T>;
    makeRpcCall(taskId: string, name: RunnerMessage.ToBroker.RPC['name'], params: unknown[]): Promise<unknown>;
    handleRpcResponse(callId: string, status: BrokerMessage.ToRunner.RPCResponse['status'], data: unknown): void;
    buildRpcCallObject(taskId: string): RPCCallObject;
    stop(): Promise<void>;
    private closeConnection;
    private waitUntilAllTasksAreDone;
}
export {};
